# Intro 

- amazon S3 is an object storage service that stores data as objects inside buckets.
- **Buckets:** Top-level container for storing objects (files)

- **Objects:** The actual data (file) + metadata with key

- **Key:** The unique identifier (like images/logo.png) or Full path to object
```
S3 URI:  s3://my-bucket/some/folder/file.txt
               └─────────────┘ └─────────────┘
                Bucket name       Object Key
S3 URI: s3://my-bucket/images/2024/01/pic1.png
key = images/2024/01/pic1.png
```

- Lifecycle rules: Automatically move/delete objects


# S3 Access Management

- Disabling **"Block all public access"** only means:
  - you are allowing yourself (or others) to apply public permissions (via bucket policies or ACLs).
  - It doesn't automatically make the bucket public
  - You still need to explicitly add a bucket policy or ACL to make it accessible.

1. ✅ IAM Policies
    - IAM policies control who (IAM users/roles) can access which S3 resources.
    - Attached to an IAM user, group, or role
    - Applies across all buckets if you use *

2. ✅ Bucket Policies
    - JSON-based policies attached directly to the bucket
    - Use to control cross-account access or public access
    - Uses same structure as IAM policies
        ```
        #Allow readonly access publically
        {
        "Effect": "Allow",
        "Principal": "*",
        "Action": "s3:GetObject",
        "Resource": "arn:aws:s3:::my-public-bucket/*"
        }
        ```

        ```
        # Cross Account access
        {
        "Version": "2012-10-17",
        "Statement": [
            {
            "Sid": "AllowAccountBReadAccess",
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::222222222222:role/S3ReaderRole"   #role in account which needs to access s3
            },
            "Action": "s3:GetObject",
            "Resource": "arn:aws:s3:::account-a-data-bucket/*"
            }
        ]
        }
        ```

3. ✅ Access Control Lists (ACLs)

- ACLs are an older, simpler way of granting object-level access to S3 resources by specifying who can access an object and what they can do.

-  You can think of ACLs like file system permissions on Linux (rw-r--r--) — per object or per bucket.
      - Assign access at bucket or object level: READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL
      - Can grant access to AWS accounts, AllUsers, or AuthenticatedUsers called *grantee*
      - Not granular (e.g., no condition support)
      - Example: Make object public via ACL:   
      `aws s3api put-object-acl --bucket my-bucket --key myfile.txt --acl public-read`

```
Example 1: Make an Object Publicly Readable

aws s3api put-object-acl \
  --bucket my-bucket \
  --key public-image.jpg \
  --acl public-read
```

```
Example 2: Grant Read Access to Another AWS Account

aws s3api put-object-acl \
  --bucket my-bucket \
  --key shared-data.json \
  --grant-read id="AccountBCanonicalID"
```

# Object Ownership 

- Object ownership in Amazon S3 defines which AWS account owns an object, regardless of who uploaded it.
- By default, the AWS account that uploads an object becomes its owner — even if the bucket belongs to another account.
- Object ownership affects:
  - Who can access, update, or delete the object
  - Whether you can use ACLs to grant permissions
  - Cross-account uploads (e.g., users or apps uploading to someone else’s bucket)

- Example Scenario:
  - Account A owns the bucket: s3://my-company-uploads
  - Account B uploads a file to that bucket
  - Account B becomes the object owner.
  - Account A (bucket owner) cannot access the object unless:
    - ACLs are used to grant permission, or
    - Object Ownership settings are changed

- Available Options:
  - Bucket owner preferred (recommended)
    - The bucket owner becomes the object owner for all uploads (including cross-account)
  - Object writer (default, legacy)
    - The uploader owns the object
  - Bucket owner enforced (recommended with ACLs disabled)
    - Bucket owner always owns the object and ACLs are disabled entirely
 
# CORS in S3 (Cross-Origin Resource Sharing)

- CORS allows your S3-hosted content to be accessed by webpages from different domains.
- Example: Your JS app on https://frontend.example.com wants to access https://my-bucket.s3.amazonaws.com.
- Without CORS, browser requests will be blocked by security policy.

**CORS Configuration Format**

```
<CORSConfiguration>
  <CORSRule>
    <AllowedOrigin>https://frontend.example.com</AllowedOrigin>
    <AllowedMethod>GET</AllowedMethod>
    <AllowedMethod>PUT</AllowedMethod>
    <AllowedHeader>*</AllowedHeader>
    <ExposeHeader>ETag</ExposeHeader>
    <MaxAgeSeconds>3000</MaxAgeSeconds>
  </CORSRule>
</CORSConfiguration>
```

# Storage Classes

- Amazon S3 offers multiple storage classes, each designed for different use cases based on:
  - Access frequency
  - Durability & availability
  - Cost
  - Retrieval time
- A storage class defines how Amazon S3 stores your objects in terms of cost, durability, availability, and performance.
- You choose the appropriate class when uploading, or via lifecycle rules

**1. S3 Standard**

-  Default class
-  For frequently accessed data
-  Fastest performance
-  High availability + durability
-  Most expensive (but worth it for hot data)
-  Use When:
   -  Serving website images/assets
   -  Hosting software/app binaries
   -  Storing logs for real-time analytics

**2. S3 Intelligent-Tiering**

- Automatically moves objects between:
  - Frequent
  - Infrequent
  - Archive tiers
- Based on access pattern (no retrieval fee)
- Use When:
  - You’re unsure about access frequency
  - You want auto-optimization
  - Data must be available immediately
- Cost:
  - Small monthly monitoring fee per object
  - Cheaper than Standard over time

**S3 Standard-IA (Infrequent Access)**

- For read-rarely, store-forever data
- Instant access, lower cost than Standard
- Retrieval costs apply
- Must store for at least 30 days
- Use When:
  - Backups
  - Older logs
  - Archived reports

**4. S3 One Zone-IA**

-  Same as Standard-IA but stored in one AZ only
-  Lower availability + durability
-  20–30% cheaper than Standard-IA
-  Use When:
   -  Non-critical backups
   -  Reproducible data
   -  Easily restorable data

**5. S3 Glacier Instant Retrieval**

-  For archival data that still needs millisecond access
-  Cheaper than IA
-  Good for medical records, media archives
-  Use When:
   -  Archived but occasionally accessed assets
   -  Faster restore than classic Glacier


**6. S3 Glacier Flexible Retrieval (Classic Glacier)**

- Retrieval: 1 min to 12 hours
- Data minimum retention: 90 days
- Cheaper than IA, good for cold archive
- Use When:
  - Regulatory backups
  - Monthly/quarterly archive restores

**7. S3 Glacier Deep Archive**

- Retrieval time: up to 12 hours
- Minimum storage duration: 180 days
- Cheapest of all
- Use When:
  - Long-term archival (e.g., tax, compliance, legal data)
  - "Write once, maybe never read again"


# Set Storage Class

- Choose storage class during upload:   
`aws s3 cp myfile.txt s3://my-bucket/ --storage-class STANDARD_IA`

- Use a Lifecycle Policy to transition objects:
```
{
  "Rules": [
    {
      "ID": "ArchiveLogs",
      "Prefix": "logs/",
      "Status": "Enabled",
      "Transitions": [
        {
          "Days": 30,
          "StorageClass": "STANDARD_IA"
        },
        {
          "Days": 90,
          "StorageClass": "GLACIER"
        }
      ],
      "Expiration": {
        "Days": 365
      }
    }
  ]
}
```


 

